\documentclass[11pt]{article}
\usepackage[latin1]{inputenc}

\usepackage{times}
\usepackage{latexsym}
\usepackage[bottom=20mm, top=20mm, left=20mm, right=20mm]{geometry}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{bussproofs}
\usepackage{comment}
\usepackage[numbers]{natbib}
\usepackage{graphicx} % Graphics support
\usepackage{caption} % Improved captions
\usepackage{subfig} % Inclusion of subfigures


\usepackage{tikz}
\usepackage{tikz-qtree}


% Set the overall layout of the tree
%\tikzstyle{level 1}=[level distance=3.5cm, sibling distance=3.5cm]
%\tikzstyle{level 2}=[level distance=3.5cm, sibling distance=2cm]

% Define styles for bags and leafs
%\tikzstyle{leaf} = [draw=none,fill=none, text width=4em, text centered]
%\tikzstyle{relation} = [ellipse, draw, text width=5em, text centered]
%\tikzstyle{branch} = [rectangle, draw, text width=6em, text centered]




%\usepackage{subfigure}

% adjust space between letters
\usepackage{microtype}

% adjust space between lines
\linespread{1.05}

% for header and footer
\usepackage{fancyhdr}

% change the font size of section
%\usepackage{sectsty}
%\sectionfont{\fontsize{12}{15}\selectfont}
%\subsectionfont{\fontsize{11}{14}\selectfont}

\usepackage{amsmath, amssymb}

\pagestyle{fancy}

\lhead{Department of Computer Science\\
Princeton University}
\chead{}
% \rhead{\includegraphics[height=15mm]{princeton_logo.jpg}}
\lfoot{}
\cfoot{}
\rfoot{}

% remove page numbers
%\thispagestyle{empty}

% no indent at the start of paragraphs
\parindent=0em

% for increasing space between paragraphs
\newcommand{\emptyline}{\vspace{5pt}}

%-----------------------------------------------------------

\begin{document}
\quad \\
\quad \\
\quad \\
\centerline{ \large{Red Oak: Something Something Algorithmic Policy}}
\vspace{1pt}\\
\centerline{Ryan Beckett and Olivier Savary B\'{e}langer} \\
\\
\centerline{April 15, 2015} \\


\section*{Introduction}

Maple \cite{Maple} proposes a SDN controller model where the behavior of the controller is defined by a function from packets to forwarding path, the algorithmic policy. The authors then show how to optimize the controller so that packets are handled without having to run the function on them. Maple does so by providing a packet API capturing each access to packet fields, and memoizing the results of the function for subsequent packets sharing the accessed fields' values. We identify a number of shortcoming to this model:
\begin{enumerate}
\item When a field value is observe, the forwarding decision only works on packets with this exact value, even if the forwarding decision is made on a much coarser range of value.Similarly, after observing some value in the environment, the forwarding decision is specialize for that particular value
  
\item It no built-in environment datastructure with automatic invalidation of decision trace when the environment is modified, which is needed to implement dynamic controllers.
  
  \item Populating the decision tree requires seeing a high number of packets, potentially slowing down the network at start-up. 
\end{enumerate}


To address these, we modify the model in the following way:
\begin{enumerate}
  \item calls to our API does not expose the values of a packet's field, answering instead boolean queries about the values being in a certain range
  \item dynamic controllers are supported through a relation data-structure which is updated through an extended API
  \item the trace tree can be generated from executing the policy on a single (potentially symbolic) packet.
\end{enumerate}



\section*{Algorithic Policies Revisited}
% Explains what algorithmic policies are, how maple was handling them and the difference with our model 
Algorithmic policies were introduced by Maple as a model for SDN controllers. An algorithmic policy consist of a function from packet to forwarding decision. Under this model, the network forwards packets as if this function was executed on each packet when entering the network. 

% Including an example policy, todo change 0 to 10 to actual IP
Figure~\ref{fig:firewall-eg} displays a policy for a stateful firewall using our API. Sources from 0 to 10 are taken to be internal to the network. If a packet is sent from an internal host to an external host, the pair of internal and external host is added to a list of trusted connection. If a packet is received from an external host, we lookup the table to see if the connection is trusted, in which case we forward the packet to its destination, otherwise we drop it.


\begin{figure}
\begin{lstlisting}
f(pkt):
  if Oak.in_range(pkt, src, 0, 10) then
     if Oak.in_range pkt dst  [(0,10)] then
        Oak.deliver
     else 
        Oak.add pkt (Oak.IpDst, Oak.IpSrc) ``conn'';
        Oak.deliver
  else if Oak.in_rel pkt (Oak.IpSrc,Oak.IpDst) ``conn'' then
         Oak.deliver
       else
         RO.drop
       end
  end                
  \end{lstlisting}
\label{fig:firewallcode}
\caption{A Stateful Firewall}
\end{figure}




\section*{API and Decision Trees}
   \subsection*{Range-based Branching}
   % Why range instead of actual value, pre-generation of rules using symbolic pre-execution


   
   

  For the stateful firewall included in figure~\ref{fig:firewallcode}, the following decision tree would be generated:


  \begin{figure}
\label{fig:decisiontree}  
\caption{Decision Tree for Stateful Firewall}     
\end{figure}
   
   % Can represent constraints on the ranges admissible given a certain topology as a series of ``true'' branches at the root of the tree.

   

   \subsection*{Forwarding Decision}
   % can give constant decision (e.g. drop() or fwd(loc) to a certain location loc), or decision based on values of the packet (e.g. deliver() which forwards to dst)

   
   \subsection*{Built-in Relation with Automatic Invalidation}
   % Relation with add and remove tuple of fields from a relation (empty at the begining), Inhabitant-based Branching 

   \begin{figure}
     \begin{lstlisting}
       
function InRange: pkt * field * value * value -> bool

\end{lstlisting}

\caption{Signature of the relation portion of the API}
\end{figure}

   
   % Computing which packets need to be sent to the controller (i.e. only the ones reaching an ``add'' or a ``remove'' node.
   
\section*{Implementation}
%that's the hope...

\subsection*{A.P.I.}
In our model, algorithmic policies interact with packets through A.P.I function calls before returning a forwarding decision. We include in Figure~\ref{fig:range_api} the core of our \lstinline|API|. 

\lstinline|field| enumerates the different fields of a packet. It can be extended to represent more fields of a packet's header. Associated with \lstinline|field| are \lstinline|range|s, possible values taken by a certain packet's field, within a given minimum value \lstinline|min_value| and maximum value \lstinline|max_value|. \lstinline|range| consists of list of integer pairs, representing a collection of intervals whose union correspond to the range of values of a packet. For simplicity, we consider integer fields here, but this could be extended, for example, to IP prefix, boolean flags, etc.

\lstinline|forwarding_decision| enumerates the different forwarding decision which can be returned by an algorithmic policy. \lstinline|Deliver| forwards the packet to its destination, \lstinline|Drop| drops the packet, \lstinline|ForwardTo i| forwards the packet to a constant location \lstinline|i| and \lstinline|Multicast fd1 fd2| duplicates the packet and handles each according to \lstinline|fd1| and \lstinline|fd2| respectively.


\begin{figure}
  \begin{lstlisting}
(* abstract packet type *)
type packet

(* a standard packet field *)
type field = IpSrc | IpDst 

(* range is a union of intervals *)
type range = (int*int) list

(* minimum, maximum value for a range interval *)
val min_value: int 
val max_value: int

(* forwarding decision can deliver, drop, forward, multicast *)
type forwarding_decision =
	| Deliver
	| Drop
	| ForwardTo of int
	| Multicast of forwarding_decision * forwarding_decision
	| Ctrl (* TODO: should not expose this *)



(* in_range p f r returns true if the value of field f of packet p is in range r, and false otherwise *)
val in_range: packet -> field -> range -> bool
\end{lstlisting}
\label{fig:range_api}
\caption{Signature of the packet and range-branching portion of the API}
\end{figure}


\begin{figure}
  \begin{lstlisting}
(* name of a relation *)
type relation = string

(* add packet's fields to a relation *)
val add: packet -> field list -> relation -> unit

(* remove packet's fields from a relation *)
val remove: packet -> field list -> relation -> unit

(* test if a packet's fields are in a relation *)
val in_relation: packet -> field list -> relation -> bool
\end{lstlisting}
\label{fig:rel_api}
\caption{Signature of the relation portion of the API}
\end{figure}

\begin{figure}
  \begin{lstlisting}
(* compile a user-function into a policy *)
val compile: (packet -> forwarding_decision) -> policy
    
(* run the user-defined policy with a set of input packets *)
val run: policy -> ((field * int) list) list  -> unit
    
(* Print the policy to stdout *)
val print_policy: policy -> unit
  \end{lstlisting}
  \label{fig:build_api}
  \caption{Signature of the interactive portion of the API}
\end{figure}

\subsection*{Tracing the Algorithmic Policy}
From an algorithmic policy, we generate a decision tree  whose leaves are forwarding decision and whose node are either branching according the range of a field value, according to a relation ,or adding and removing components from a relation.

\begin{figure}
\begin{lstlisting}
let compile (f: packet -> forwarding_decision) : policy =
      push most general packet to (empty) stack
      set the current location to be the root of an empty decision tree
      while (stack is not empty)
         pop the top of the stack as pkt
         run f of pkt resulting in a forwarding decision fd (and a modified packet pkt)
         record the forwarding decision for the symbolic packet pkt at the current location in the decision tree
         set the current location to be the root of the decision tree and repeat
  
\end{lstlisting}
\caption{Pseudocode for the compile function}
\end{figure}

To do so, we repeatedly run the algorithmic policy \lstinline|f| on symbol packets generated to explore every reachable path.
We begin by calling \lstinline|f| on a symbolic packet covering the full range of value for each of its fields.

When \lstinline|f| calls \lstinline|in_range| to learn if the field \lstinline|fld|'s value is in the range \lstinline|r|, we (1) create an \lstinline|Inrange| branching node in the decision tree (2) refine the current symbolic packet to represent all packets in range \lstinline|r| that could reach this test in the algorithmic policy and return true (3) push on the stack of packets to process a symbolic packets representing all packets in the complement of \lstinline|r| for field \lstinline|fld|.

Similarly, when the algorithmic policy calls \lstinline|in_relation| to learn if fields \lstinline|flds|'s value are in a relation \lstinline|rel|, we (1) create an \lstinline|Inrelation| branching node in the decision tree (2) tag the current packet as being in the relation, return true (3) push on the stack of packets to process the same packet tagged as not being part of relation \lstinline|rel|.

When \lstinline|f| calls \lstinline|add| or \lstinline|remove|, we record in the decision the current symbolic packet, the relation and the fields being added or removed from the relation before continuing with the execution of \lstinline|f|.

When \lstinline|f| returns with a forwarding decision, we record it, paired with the current symbolic packet, as a leaf node at the current position in the decision tree. We then pop the next packet from the stack of packets to process and restart tracing the policy from the root of the decision tree, exploring another path of \lstinline|f|.  


\subsection*{Simulating the Network Controller}

\begin{figure}
\begin{lstlisting}
let run (pol: policy) (inputs: ((field*int) list) list) : unit =
      build the symbolic rules for policy pol
      generate the concrete rules with all relations empty
      for each packets in input,
          find the first of the current rule matching the packet, and record the forwarding decision fd
          if packet is sent to the controller then
              evaluate the policy on the packet, potentially adding or removing tuples from relations, record forwarding decision fd'
              regenerate concrete rules
              forward the packet according the forwarding decision fd'
          else
              forward the packet according to fd 
\end{lstlisting}

\caption{Pseudocode for the run function}
  \end{figure}



\subsection*{Optimizations}
   % 1) expand tree before add/remove nodes with a match on that relation ( based on add(p); add(p) == add(p) so can shortcircuit if p is already in the relation)
   % 2) Prune dead subtree on empty ranges and add/remove which do not affect any inhabitant-based branching.


\section*{Evaluation}
% 1) optimality w.r.t. packets seen by the controler?
% 2) more examples
% 3) simulated run


\section*{Related Work}
% deeper comparison with Maple

%???

\section*{Future Work and Conclusion}


\bibliographystyle{plainnat}
\bibliography{bibi}



\end{document}
