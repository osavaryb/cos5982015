

\documentclass[preprint]{sigplanconf}
\usepackage[latin1]{inputenc}
\usepackage{times}
\usepackage{latexsym}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{bussproofs}
\usepackage{comment}
\usepackage[numbers]{natbib}
\usepackage{graphicx} % Graphics support
\usepackage{caption} % Improved captions
\usepackage{subfig} % Inclusion of subfigures


\usepackage{tikz}
\usepackage{tikz-qtree}


% Set the overall layout of the tree
%\tikzstyle{level 1}=[level distance=3.5cm, sibling distance=3.5cm]
%\tikzstyle{level 2}=[level distance=3.5cm, sibling distance=2cm]

% Define styles for bags and leafs
%\tikzstyle{leaf} = [draw=none,fill=none, text width=4em, text centered]
%\tikzstyle{relation} = [ellipse, draw, text width=5em, text centered]
%\tikzstyle{branch} = [rectangle, draw, text width=6em, text centered]




%\usepackage{subfigure}

% adjust space between letters
\usepackage{microtype}

% adjust space between lines
\linespread{1.05}

% for header and footer
\usepackage{fancyhdr}

% change the font size of section
%\usepackage{sectsty}
%\sectionfont{\fontsize{12}{15}\selectfont}
%\subsectionfont{\fontsize{11}{14}\selectfont}

\usepackage{amsmath, amssymb}

\pagestyle{fancy}

\lhead{Department of Computer Science\\
Princeton University}
\chead{}
% \rhead{\includegraphics[height=15mm]{princeton_logo.jpg}}
\lfoot{}
\cfoot{}
\rfoot{}

% remove page numbers
%\thispagestyle{empty}

% no indent at the start of paragraphs
\parindent=0em

% for increasing space between paragraphs
\newcommand{\emptyline}{\vspace{5pt}}

\title{Red Oak: Something Something Algorithmic Policy}
 \authorinfo{Ryan Beckett}{Princeton University}{rbeckett@princeton.edu}
 \authorinfo{Olivier Savary B\'{e}langer}{Princeton University}{olivierb@princeton.edu}


%-----------------------------------------------------------

\begin{document}
\maketitle

\begin{abstract} ...
\end{abstract}

\section*{Introduction}

Maple \cite{Maple} proposes a SDN controller model where the behavior of the controller is defined by a function from packets to forwarding path, the algorithmic policy. The authors then show how to optimize the controller so that packets are handled without having to run the function on them. Maple does so by providing a packet API capturing each access to packet fields, and memoizing the results of the function for subsequent packets sharing the accessed fields' values. We identify a number of shortcoming to this model:
\begin{enumerate}
\item When a field value is observe, the forwarding decision only works on packets with this exact value, even if the forwarding decision is made on a much coarser range of value.Similarly, after observing some value in the environment, the forwarding decision is specialize for that particular value
  
\item It no built-in environment datastructure with automatic invalidation of decision trace when the environment is modified, which is needed to implement dynamic controllers.
  
  \item Populating the decision tree requires seeing a high number of packets, potentially slowing down the network at start-up. 
\end{enumerate}


To address these, we modify the model in the following way:
\begin{enumerate}
  \item calls to our API does not expose the values of a packet's field, answering instead boolean queries about the values being in a certain range
  \item dynamic controllers are supported through a relation data-structure which is updated through an extended API
  \item the trace tree can be generated from executing the policy on a single (potentially symbolic) packet.
\end{enumerate}



\section*{Algorithic Policies Revisited}
% Explains what algorithmic policies are, how maple was handling them and the difference with our model 
Algorithmic policies were introduced by Maple as a model for SDN controllers. An algorithmic policy consist of a function from packet to forwarding decision. Under this model, the network forwards packets as if this function was executed on each packet when entering the network. 


Figure~\ref{fig:firewall-eg} displays a policy for a stateful firewall using our API. Sources from 0 to 10 are taken to be internal to the network. If a packet is sent from an internal host to an external host, the pair of internal and external host is added to a list of trusted connection. If a packet is received from an external host, we lookup the table to see if the connection is trusted, in which case we forward the packet to its destination, otherwise we drop it.


\begin{figure}[ht]
\begin{lstlisting}
f(pkt):
  if in_range(pkt, src, 0, 10) then
     if in_range pkt dst  [(0,10)] then
        deliver
     else 
        add pkt (IpDst, IpSrc) ``conn'';
        deliver
  else if in_rel pkt (IpSrc,IpDst) ``conn'' then
         deliver
       else
         RO.drop
       end
  end                
  \end{lstlisting}

\caption{A Stateful Firewall}
\label{fig:firewallcode}
\end{figure}




\section*{Decision Trees and Algorithmic Policies}

   \subsection*{Range-based Branching}
   % Why range instead of actual value, pre-generation of rules using symbolic pre-execution


   
   

  For the stateful firewall included in figure~\ref{fig:firewallcode}, the following decision tree would be generated:


  \begin{figure}

\caption{Decision Tree for Stateful Firewall}     
\label{fig:decisiontree}  
  \end{figure}
   
   % Can represent constraints on the ranges admissible given a certain topology as a series of ``true'' branches at the root of the tree.



     \subsection*{Built-in Relation with Automatic Invalidation}
   % Relation with add and remove tuple of fields from a relation (empty at the begining), Inhabitant-based Branching 


   
   % Computing which packets need to be sent to the controller (i.e. only the ones reaching an ``add'' or a ``remove'' node.

     
  

   \subsection*{Forwarding Decision}
   % can give constant decision (e.g. drop() or fwd(loc) to a certain location loc), or decision based on values of the packet (e.g. deliver() which forwards to dst)
   Under the big switch model, the forwarding decisions returned by algorithmic policies are destination-based rather than path-based. For example, the algorithmic policy may decide to deliver a packet, at which point this interpretation will be interpreted as forwarding a packet along a path terminating at the packet's destination. Packets may also be dropped, or forwarding to a static location. Our model also allows for dynamic forwarding based on component of relation, for example to the last seen location of a host according to a MAC-learning controller.
   

   \subsection*{Combining Algorithmic Policies}
   % cross, ``holes''
   As algorithmic policies under our model are functions of the host language, we inherit the latter's function space ability, allowing, amongst other things, for compositon of algorithmic policies and higher-order algorithmic policies.

\begin{figure}[ht]
\begin{lstlisting}

let filter_src_range f r pkt =
 if in_range pkt IpSrc r then
    f pkt
 else
   Drop   
\end{lstlisting}

\caption{Example of a Partial Algorithmic Policy}
\label{fig:ex-hole}
\end{figure}

   
   For example, we include in Figure~\ref{fig:ex-hole} the source code for \lstinline|filter_src_range| a partial algorithmic policy which, given an algorithmic policy \lstinline|f| and a range \lstinline|r|, will forwards all packets whose source IP is within range \lstinline|r| and drop the packet otherwise. 


   \begin{figure}[ht]
\begin{lstlisting}
let f_cross (f_1) (f_2) pkt =
  let d_1 = f_1 pkt in
  let d_2 = f_2 pkt in
  Multicast (d_1,d_2)
\end{lstlisting}

\caption{Example of a Composition Operator}
\label{fig:ex-cross}
\end{figure}
   
Various composition operator may be built as host language function to combine multiple algorithmic policies into a single one. For example, \lstinline|f_cross|, included in Figure~\ref{fig:ex-cross}, runs algorithmic policy \lstinline|f_1| and \lstinline|f_2| on input packets and multicast them according to both forwarding decisions. 
   
\section*{Implementation}
%that's the hope...

\subsection*{A.P.I.}
In our model, algorithmic policies interact with packets through A.P.I function calls before returning a forwarding decision. We include in Figure~\ref{fig:range_api} the core of our \lstinline|A.P.I.|. 
\lstinline|field| enumerates the different fields of a packet. It can be extended to represent more fields of a packet's header. Associated with \lstinline|field| are \lstinline|range|s, possible values taken by a certain packet's field, within a given minimum value \lstinline|min_value| and maximum value \lstinline|max_value|. \lstinline|range| consists of list of integer pairs, representing a collection of intervals whose union correspond to the range of values of a packet. For simplicity, we consider integer fields here, but this could be extended, for example, to IP prefix, boolean flags, etc.

\lstinline|forwarding_decision| enumerates the different forwarding decision which can be returned by an algorithmic policy. \lstinline|Deliver| forwards the packet to its destination, \lstinline|Drop| drops the packet, \lstinline|ForwardTo i| forwards the packet to a constant location \lstinline|i| and \lstinline|Multicast fd1 fd2| duplicates the packet and handles each according to \lstinline|fd1| and \lstinline|fd2| respectively.

Algorithmic policy may base their forwarding decision on the result of calling the \lstinline|in_range pkt fld r|, which returns whether value of packet \lstinline|pkt| at field \lstinline|fld| is in the range \lstinline|r|.

\begin{figure}[ht]
  \begin{lstlisting}
type packet

type field = IpSrc | IpDst 

type range = (int*int) list

val min_value: int 
val max_value: int

type forwarding_decision =
	| Deliver
	| Drop
	| ForwardTo of int
	| Multicast of forwarding_decision * forwarding_decision
	| Ctrl




val in_range: packet -> field -> range -> bool
\end{lstlisting}

\caption{Signature of the packet and range-branching portion of the API}
\label{fig:range_api}
\end{figure}



In Figure~\ref{fig:rel_api}, we include the relation portion of the \lstinline|A.P.I.|, used to model stateful controller programs. A \lstinline|relation| represents a table in which each row contains a series of field values. It is referred to by a string. Policy writer may add a row to a relation \lstinline|rel| by calling the function \lstinline|add pkt flds rel|, which will populate the new row with the fields \lstinline|flds|' values of the current packet \lstinline|pkt|. Similarly, they may remove a row containing exactly the values of fields \lstinline|flds|' values of the current packet \lstinline|pkt| by calling \lstinline|remove pkt flds rel|. Finally, one may test if the values of fields \lstinline|flds| of current packet \lstinline|pkt| are in relation \lstinline|rel| by calling \lstinline|in_relation pkt flds rel|.



\begin{figure}[ht]
  \begin{lstlisting}
type relation = string

val add: packet -> field list -> relation -> unit

val remove: packet -> field list -> relation -> unit

val in_relation: packet -> field list -> relation -> bool
\end{lstlisting}

\caption{Signature of the relation portion of the API}
\label{fig:rel_api}
\end{figure}




\begin{figure}[ht]
  \begin{lstlisting}
(* compile a user-function into a policy *)
val compile: (packet -> forwarding_decision) -> policy
    
(* run the user-defined policy with a set of input packets *)
val run: policy -> ((field * int) list) list  -> unit
    
(* Print the policy to stdout *)
val print_policy: policy -> unit
  \end{lstlisting}

  \caption{Signature of the interactive portion of the API}
  \label{fig:build_api}
\end{figure}

\subsection*{Tracing the Algorithmic Policy}
From an algorithmic policy, we generate a decision tree  whose leaves are forwarding decision and whose node are either branching according the range of a field value, according to a relation ,or adding and removing components from a relation.

\begin{figure*}[ht]
\begin{lstlisting}
let compile (f: packet -> forwarding_decision) : policy =
      push most general packet to (empty) stack
      set the current location to be the root of an empty decision tree
      while (stack is not empty)
         pop the top of the stack as pkt
         run f of pkt resulting in a forwarding decision fd (and a modified packet pkt)
         record the forwarding decision for the symbolic packet pkt at the current location in the decision tree
         set the current location to be the root of the decision tree and repeat
  
\end{lstlisting}
\caption{Pseudocode for the compile function}
\label{fig:compile-pseudo}
\end{figure*}

To do so, we repeatedly run the algorithmic policy \lstinline|f| on symbol packets generated to explore every reachable path.
We begin by calling \lstinline|f| on a symbolic packet covering the full range of value for each of its fields.

When \lstinline|f| calls \lstinline|in_range| to learn if the field \lstinline|fld|'s value is in the range \lstinline|r|, we
\begin{enumerate}
\item  create an \lstinline|Inrange| branching node in the decision tree
\item refine the current symbolic packet to represent all packets in range \lstinline|r| that could reach this test in the algorithmic policy and return true
\item push on the stack of packets to process a symbolic packets representing all packets in the complement of \lstinline|r| for field \lstinline|fld|.
\end{enumerate}


Similarly, when the algorithmic policy calls \lstinline|in_relation| to learn if fields \lstinline|flds|'s value are in a relation \lstinline|rel|, we
\begin{enumerate}
  \item create an \lstinline|Inrelation| branching node in the decision tree
  \item tag the current packet as being in the relation, return true
  \item push on the stack of packets to process the same packet tagged as not being part of relation \lstinline|rel|.
\end{enumerate}
When \lstinline|f| calls \lstinline|add| or \lstinline|remove|, we record in the decision the current symbolic packet, the relation and the fields being added or removed from the relation before continuing with the execution of \lstinline|f|.

When \lstinline|f| returns with a forwarding decision, we record it, paired with the current symbolic packet, as a leaf node at the current position in the decision tree. We then pop the next packet from the stack of packets to process and restart tracing the policy from the root of the decision tree, exploring another path of \lstinline|f|.  


\subsection*{Simulating the Network Controller}

We provide a function \lstinline|run| to simulate the controller policy on a sequence of packets. \lstinline|policy| is an abstract datatype solely returned by \lstinline|compile| (see Fig.~\ref{fig:compile-pseudo}). In addition to the policy, \lstinline|run| takes in a list of packets represented as list of pairs of \lstinline|field| and \lstinline|int|, representing the values of the different fields of the packet. We expect all fields to be set exactly once for each packet in the list.

\lstinline|run| starts by building the symbolic rules for the given policy, and generating the concrete rules assuming all relations to be empty. In sequence, packet are matched with the current concrete rules, recording the forwarding decision. If a packet is sent to the controller, we evaluate the policy on the packet, potentially adding or removing tuples from relations. We then re-generate the concrete rules with the updated relation, before recording the forwarding decision.

\begin{figure*}[ht]
\begin{lstlisting}
let run (pol: policy) (inputs: ((field*int) list) list) : unit =
      build the symbolic rules for policy pol
      generate the concrete rules with all relations empty
      for each packets in input,
          find the first of the current rule matching the packet, and record the forwarding decision fd
          if packet is sent to the controller then
              evaluate the policy on the packet, potentially adding or removing tuples from relations, record forwarding decision fd'
              regenerate concrete rules
              forward the packet according the forwarding decision fd'
          else
              forward the packet according to fd 
\end{lstlisting}

\caption{Pseudocode for the run function}
\label{fig:run-pseudo}
  \end{figure*}



\subsection*{Optimizations}
   % 1) expand tree before add/remove nodes with a match on that relation ( based on add(p); add(p) == add(p) so can shortcircuit if p is already in the relation)
   % 2) Prune dead subtree on empty ranges and add/remove which do not affect any inhabitant-based branching.


% probably no evaluation :(
\section*{Evaluation}
% 1) optimality w.r.t. packets seen by the controler?
% 2) more examples
% 3) simulated run


\section*{Related Work}
% deeper comparison with Maple

%???

\section*{Future Work and Conclusion}


\bibliographystyle{plainnat}
\bibliography{bibi}



\end{document}
