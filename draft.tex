\documentclass[12pt]{article}
\usepackage{times}
\usepackage{latexsym}
\usepackage[bottom=20mm, top=20mm, left=20mm, right=20mm]{geometry}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{bussproofs}
\usepackage{comment}
\usepackage[numbers]{natbib}
\usepackage{graphicx} % Graphics support
\usepackage{caption} % Improved captions
\usepackage{subfig} % Inclusion of subfigures
%\usepackage{subfigure}

% adjust space between letters
\usepackage{microtype}

% adjust space between lines
\linespread{1.05}

% for header and footer
\usepackage{fancyhdr}

% change the font size of section
%\usepackage{sectsty}
%\sectionfont{\fontsize{12}{15}\selectfont}
%\subsectionfont{\fontsize{11}{14}\selectfont}

\usepackage{amsmath, amssymb}

\pagestyle{fancy}

\lhead{Department of Computer Science\\
Princeton University}
\chead{}
% \rhead{\includegraphics[height=15mm]{princeton_logo.jpg}}
\lfoot{}
\cfoot{}
\rfoot{}

% remove page numbers
%\thispagestyle{empty}

% no indent at the start of paragraphs
\parindent=0em

% for increasing space between paragraphs
\newcommand{\emptyline}{\vspace{5pt}}

%-----------------------------------------------------------

\begin{document}
\quad \\
\quad \\
\quad \\
\centerline{ \large{Red Oak: Something Something Algorithmic Policy}}
\vspace{1pt}\\
\centerline{Ryan Beckett and Olivier Savary B\'{e}langer} \\
\\
\centerline{April 15, 2015} \\


\section*{Introduction}
% possibly in introduction instead?
Maple \cite{Maple} proposes a SDN controller model where the behavior of the controller is defined by a function from packets to forwarding path, the algorithmic policy. The authors then show how to optimize the controller so that packets are handled without having to run the function on them. Maple does so by providing a packet API capturing each access to packet fields, and memoizing the results of the function for subsequent packets sharing the accessed fields' values. We identify a number of shortcoming to this model:
\begin{enumerate}
\item % packet value granularity too fine
  \item % environmentgranularity too fine, no built-in support for dynamic controllers
  \item % not proactive
\end{enumerate}

To address these, we modify the model in the following way:
\begin{enumerate}
  \item calls to our API does not expose the values of a packet's field, answering instead boolean queries about the values being in a certain range
  \item dynamic controllers are supported through a relation data-structure which is updated through an extended API
  \item the trace tree can be generated from executing the policy on a single (potentially symbolic) packet.
\end{enumerate}


% Including an example policy, todo change 0 to 10 to actual IP
Figure~\ref{fig:firewall-eg} displays a policy for a stateful firewall using our API. Sources from 0 to 10 are taken to be internal to the network. If a packet is sent from an internal host to an external host, the pair of internal and external host is added to a list of trusted connection. If a packet is received from an external host, we lookup the table to see if the connection is trusted, in which case we forward the packet to its destination, otherwise we drop it.


\begin{figure}
\begin{lstlisting}
f(pkt):
  if RO.InRange(pkt, src, 0, 10) then
     if RO.InRange(pkt, dst, 0, 10) then
        RO.deliver()
     else 
        RO.add(pkt, (dst, src), trusted);
        RO.deliver()
  else if (RO.InSet(pkt, (src,dst), trusted) then
         RO.deliver()
       else
         RO.drop
       end
  end                
  \end{lstlisting}

\caption{A Stateful Firewall}
\end{figure}

\section*{Algorithic Policies Revisited}
% Explains what algorithmic policies are, how maple was handling them and the difference with our model 


\section*{API and Decision Trees}
   \subsection*{Range-based Branching}
   % Why range instead of actual value, pre-generation of rules using symbolic pre-execution

   \begin{figure}
\begin{lstlisting}
Module RO

Type pkt (* contains a range for each field *)

Type field (* enum each field *)

function InRange: pkt * field * value * value -> bool

\end{lstlisting}

\caption{Signature of the packet portion of the API}
\end{figure}

   
   
   % Can represent constraints on the ranges admissible given a certain topology as a series of ``true'' branches at the root of the tree.


   \subsection*{Forwarding Decision}
   % can give constant decision (e.g. drop() or fwd(loc) to a certain location loc), or decision based on values of the packet (e.g. deliver() which forwards to dst)

   
   \subsection*{Built-in Relation with Automatic Invalidation}
   % Relation with add and remove tuple of fields from a relation (empty at the begining), Inhabitant-based Branching 

   \begin{figure}
     \begin{lstlisting}
       
function InRange: pkt * field * value * value -> bool

\end{lstlisting}

\caption{Signature of the relation portion of the API}
\end{figure}

   
   % Computing which packets need to be sent to the controller (i.e. only the ones reaching an ``add'' or a ``remove'' node.
   
\section*{Implementation}
%that's the hope...

   \subsection*{Optimizations}
   % 1) expand tree before add/remove nodes with a match on that relation ( based on add(p); add(p) == add(p) so can shortcircuit if p is already in the relation)
   % 2) Prune dead subtree on empty ranges and add/remove which do not affect any inhabitant-based branching.


\section*{Evaluation}
% 1) optimality w.r.t. packets seen by the controler?
% 2) more examples
% 3) simulated run


\section*{Related Work}
% deeper comparison with Maple

%???

\section*{Future Work and Conclusion}


\bibliographystyle{plainnat}
\bibliography{bibi}



\end{document}
